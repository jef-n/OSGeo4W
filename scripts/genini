#!/usr/bin/perl
# Copyright (C) 2005, 2006, 2007 Christopher Faylor
#
# This software is a copyrighted work licensed under the terms of the
# GNU General Public License.  See http://www.gnu.org/copyleft/gpl.html
# for details.
#
use File::Basename;
use Digest::MD5;
use Getopt::Long;
use POSIX;

use strict;

sub mywarn(@);
sub myerror(@);
sub usage();
sub arch_handler(@);

my %md5s;

if( open F, "md5sums" ) {
    while(<F>) {
        chomp;
        my($md5,$s,$t,$f) = split / /;
        next unless -f $f;
        $md5s{$f}{md5} = $md5;
        $md5s{$f}{s} = $s;
        $md5s{$f}{t} = $t;
    }
    close F;
}


my @okmissing = qw'message ldesc build-depends';
my ($outfile, $help, $recursive);
my $arch = 'x86_64';
my $release;
my $date;
my $startts;
my $alllicenses = 0;
GetOptions('okmissing=s'=>\@okmissing,
           'output=s'=>\$outfile,
           'help'=>\$help,
           'release=s'=>\$release,
           'arch=s'=>\&arch_handler,
           'recursive'=>\$recursive,
           'date=s'=>\$date,
           'alllicenses'=>\$alllicenses) or usage;


my %licfile;
my %licmap;
my %acceptable;

unless($alllicenses) {
    if( open F, "license.map" ) {
        while(<F>) {
            chomp;
            my($first,$second,$comment) = split / /;
            $licmap{$second} = $first;
        }
    }

    if( open F, "acceptable.lst" ) {
        while(<F>) {
            chomp;
            my($id,$comment) = split / /;
            $acceptable{$id} = 1;
        }
    }
}

if($date) {
    usage unless $date =~ /^(\d{4})-(\d{2})-(\d{2})$/;
    $startts = POSIX::mktime( 0, 0, 0, $3, $2-1, $1-1900);
    usage unless defined $startts;
}
$help and usage;

@main::okmissing{@okmissing} = @okmissing;

sub arch_handler (@) {
   my ($opt_name, $opt_value) = @_;
   die "invalid arch specified: '$opt_value'"
      unless $main::valid_arch{lc $opt_value};
   $arch = lc $opt_value;
}

if (defined($outfile)) {
    open(STDOUT, '>', $outfile) or die "$0: can't open $outfile - $!\n";
}

my %pkg;

for my $f (@ARGV) {
    if (-d "$f/.") {
        parsedir($f);
    } else {
        parse($f);
    }
}

print <<'EOF';
# This file is automatically generated.  If you edit it, your
# edits will be discarded next time the file is generated.
#
EOF

my $ts = time();
print "release: $release\n" if $release;
print "arch: $arch\n";
print "setup-timestamp: $ts\n";
print "$main::setup_version\n" if $main::setup_version;

undef $main::curfile;
for my $p (sort keys %pkg) {
    # print STDERR "P:$p requires:$pkg{$p}{''}{requires}\n";
    print "\n@ $p\n";
    for my $key ('sdesc', 'ldesc', 'category', 'requires', 'message') {
        my $val = $pkg{$p}{''}{$key};
        if (!defined($val) && $pkg{$p}{''}{'install'} !~ /_obsolete/o) {
            mywarn "package $p is missing a $key field"
              unless defined $main::okmissing{$key};
        } else {
            if ($key eq 'requires') {
                for my $p1 (split(' ', $val)) {
                    mywarn "package $p requires an unknown package '$p1'"
                      unless exists $pkg{$p1};
                }
            } elsif ($key eq 'build-depends') {
                for my $p1 (split(' ', $val)) {
                    mywarn "build of package $p requires an unknown package '$p1'"
                      unless exists $pkg{$p1};
                }
            } elsif ($key eq 'category') {
                for my $c (split(' ', $val)) {
                    mywarn "package $p uses an invalid category '$c'"
                      unless $main::categories{lc $c};
                }
            }
            print "$key: ", $val, "\n" if defined($val) and $val ne "";
        }
    }
    for my $what ('', "[prev]\n", "[test]\n") {
        $pkg{$p}{$what} or next;
        print "$what";
        for my $key ('version', 'install', 'source', 'license') {
            my $val = $pkg{$p}{$what}{$key} or next;
            print "$key: ", $val, "\n";
        }
    }
}

open F, ">md5sums";
for my $f (keys %md5s) {
    print F
        $md5s{$f}{md5} . " " .
        $md5s{$f}{s} . " " .
        $md5s{$f}{t} . " " .
        $f . "\n";
}
close F;

sub get {
    my $FH = shift;
    my $keyhint = shift;
    my $val = shift;

    if ($keyhint eq 'message') {
        my ($kw, $rest) = $val =~ /^([^"'\s]+)\s+(.*)$/;
        return undef unless defined($kw) && defined($rest);
        return $kw . ' ' . get($FH, 'ldesc', $rest);
    } elsif (substr($val, 0, 1) ne '"') {
        $val = '"'. $val . '"' if $keyhint eq 'ldesc' || $keyhint eq 'sdesc';
    } else {
        while (length($val) == 1 || $val !~ /"$/os) {
            $_ = <$FH>;
            length or last;
            chomp;
            s/(\S)\s+$/$1/;
            $val .= "\n" . $_;
        }
    }
    $val =~ s/(.)"(.)/$1'$2/mog;
    return $val;
}

sub parse {
    my $f = shift;
    my $pname = shift;
    my $what;
    $main::curfile = $f;
    $. = 0;
    open(\*F, '<', $f) or die "$0: couldn't open $f - $!\n";
    while (<F>) {
        chomp;
        s/#.*$//o;
        s/^\s+//o;
        s/(\S)\s+$/$1/o;
        length or next;
        /^setup-timestamp:/ and do {
            $main::setup_timestamp = $_;
            next;
        };
        /^setup-version:/ and do {
            $main::setup_version = $_;
            next;
        };
        /^arch:/ and do {
            next;
        };
        /^release:/ and do {
            next;
        };
        /^skip:/ and do {
            next;
        };
        /^\@\s+(\S+)/ and do {
            $pname = $1;
            $what = '';
            next;
        };
        /^([^:]+):\s*(.*)$/ and do {
            my $key = $1;
            my $val = $2;
            if ($key !~ /^(?:prev|curr|test)/) {
                $pkg{$pname}{$what}{$key} = get(\*F, $key, $val);
            } else {
                if ($key eq 'curr') {
                    $key = '';
                } else {
                    $key = "[$key]\n";
                }
                $pkg{$pname}{$key}{'version'} = $val;
            }
            next if defined $val;
        };
        /^\[[^\]]+\]/ and do {
            $what = $_ . "\n";
            next;
        };
        die "$0: unrecognized input at line file $f, line $.\n";
    }
}

sub compare_versions {
    my($a, $b) = @_;

    return 0 if $a eq $b;

    my $r;
    while($a ne "" && $b ne "") {
        my($ai, $r) = $a =~ /^(\d*)(.*)$/;
        $a = $r;
        my($bi, $r) = $b =~ /^(\d*)(.*)$/;
        $b = $r;

        my $isnum = $ai ne "";

        unless($isnum) {
            ($ai, $r) = $a =~ /^(\D*)(.*)/;
            $a = $r;
            ($bi, $r) = $b =~ /^(\D*)(.*)/;
            $b = $r;
        }

        return $isnum ? 1 : -1 if $bi eq "";

        if($isnum) {
            $ai =~ s/^0+//;
            $bi =~ s/^0+//;

            if(length($ai) > length($bi)) {
                return 1;
            } elsif(length($ai) < length($bi)) {
                return -1;
            }
        }

        my $r = $ai cmp $bi;
        return $r unless $r == 0;
        return $a =~ /^rc/i ? -1 : 1 if $isnum && $a =~ /^rc/i != $b =~ /^rc/i;
    }

    if($a eq "" && $b eq "") {
        return 0;
    } else {
        return $a eq "" ? -1 : 1;
    }
}

sub parsedir {
    my $d = shift;
    my $pname = basename($d);
    mywarn "overwriting previous information for $pname" if exists $pkg{$pname};
    delete $pkg{$pname};
    if ($recursive) {
        for my $drecur (glob("$d/*/.")) {
            last if $drecur =~ /\*/;
            parsedir(dirname($drecur));
        }
    }
    my $setup_hint = "$d/setup.hint";
    return unless -e $setup_hint;
    parse("$setup_hint", $pname);

    my $explicit = 0;
    for my $what ('', "[prev]\n", "[test]\n") {
        my $x = $pkg{$pname}{$what};
        next unless $x->{'version'};
        $explicit = 1;
        addfiles($pname, $x, $d);
    }

    return if $explicit;

    my @files = sort {
        my ($an, $av) = getver($a);
        my ($bn, $bv) = getver($b);

        my ($ap, $bp);
        ($av, $ap) = $av =~ /^(.+)-(\d+)$/;
        ($bv, $bp) = $bv =~ /^(.+)-(\d+)$/;

        my $r;
        if( defined $ap && defined $bp ) {
            $r = ($an ne $bn) ?
                $an cmp $bn :
                        $av ne $bv ?
                                compare_versions($av, $bv) :
                                $ap <=> $bp;
        } else {
            warn "invalid version $a" unless defined $ap;
            warn "invalid version $b" unless defined $bp;
            $r = $a cmp $b;
        }
        return $r;
    } grep { !/-src\.tar.bz2/ } glob("$d/*.tar.bz2");
    @files = grep { (stat($_))[9]<=$startts; } @files if $startts;

    if (!@files) {
        myerror "not enough package files in $d";
        return;
    }
    for my $what ('', "[prev]\n") {
        my $f = pop @files or last;
        $pkg{$pname}{$what}{-unused} = 1;
        my $x = $pkg{$pname}{$what};
        my $p;
        ($p, $x->{'version'}) = getver($f);
        addfiles($p, $x, $d);
    }
}

sub addfiles {
    my $pname = shift;
    my $x = shift;
    my $d = shift;
    my $install = tarball($d, $pname, $x->{'version'});
    filer($x, 'install', $install);

    my $t = license($d, ".txt", $pname, $x->{'version'});
    my $p = license($d, ".pdf", $pname, $x->{'version'});
    my $r = license($d, ".rtf", $pname, $x->{'version'});

    if( -e $p && (! -e $t || (stat($p))[9] > (stat($t))[9] ) ) {
        system "umask 0111; pdftotext -layout -enc ASCII7 '$p' - >'$t'";
    } elsif( -e $r && (! -e $t || (stat($r))[9] > (stat($r))[9] ) ) {
        system "umask 0111; catdoc -dus-ascii '$r' >'$t'";
    }

    print STDERR "$pname: no license [$t]\n" unless -e $t || $pname =~ /^(proj-data|python3-.*)/;

    filer($x, 'license', $t) if -e $t;

    if ($pkg{$pname}{''}{'external-source'}) {
        $pname = $pkg{$pname}{''}{'external-source'};
        $d = finddir($d, $pname) or return;
    }

    my $source  = tarball($d, $pname, $x->{'version'}, 'src');
    filer($x, 'source', $source);
}

sub getver {
    my $f = basename($_[0]);
    my @a = ($f =~ /^(.*?)-(\d.*)\.tar/);
    return wantarray ? @a : $a[1];
}

sub filer {
    my $x = shift;
    my $what = shift;
    my $f = shift;

    unless( -r $f ) {
        myerror "can't open $f - $!" unless $main::okmissing{$what};
        return undef;
    }

    my $digest = $md5s{$f}{md5};
    my ($s,$t) = (stat $f)[7,9];        # size and mtime

    unless( defined $digest && $md5s{$f}{s}==$s && $md5s{$f}{t}==$t ) {
      open(*F, '<', $f);
      my $md5 = Digest::MD5->new;
      $md5->addfile(\*F);
      $digest = $md5->hexdigest;

      $md5s{$f}{md5} = $digest;
      $md5s{$f}{s} = $s;
      $md5s{$f}{t} = $t;
    }

    if( !$alllicenses && $what eq 'license' ) {
        $digest = $licmap{$digest} if exists $licmap{$digest};

        unless( exists $licfile{$digest} ) {
                $licfile{$digest} = $f;
        } else {
                $f = $licfile{$digest};
        }

        return if exists $acceptable{$digest};
    }

    $x->{$what} = join(' ', $f, -s $f, $digest);
}

sub tarball {
    my $d = shift;
    return "$d/" . join('-', @_) . '.tar.bz2';
}

sub license {
    my $d = shift;
    my $ext = shift;
    return "$d/" . join('-', @_) . $ext;
}

sub fnln {
    return $main::curfile ? "$main::curfile:$.: " : '';
}

sub mywarn(@) {
    warn "warning: " . fnln . "@_\n";
}

sub myerror(@) {
    warn "error: " . fnln . "@_\n";
}

sub finddir {
    my $d = $_[0];
    my $pname = $_[1];
    while (($d = dirname($d)) ne '.' && length($d)) {
        return "$d/$pname" if -d "$d/$pname/.";
    }
    myerror "couldn't find package directory for external-source '$pname'";
    return undef;
}

sub usage() {
    print STDERR <<'EOF';
Usage: genini [--okmissing=key ...] [--recursive] [--output=file] [--help] [--date=yyyy-mm-dd] [setup.ini] [dir ...]
Create OSGeo4W setup.ini from setup.ini, setup.hint and tar ball information.

    --okmissing=key    Don't warn if key is missing from setup.ini or setup.hint
                       or if some expected `source' or `install' tarballs are
                       missing. Option may be repeated. --okmissing=install is
                       useful if hint files contain `prev' or `test' entries for
                       missing tarballs. --okmissing=source is useful for
                       LOCAL-ONLY srcless install media.
    --recursive        Recurse all subdirectories of specified dirs
    --arch=x86|x86_64  Must be either x86 or x86_64. Defaults to x86.
    --date=yyyy-mm-dd  Generate ini for an older state (all newer files will be ignored)
    --release=string   Optional repository id: release, staging, etc.
    --output=file      output setup.ini info to file
    --help             display this message

Report bugs to osgeo4w mailing list.
EOF
    exit 0;
}

BEGIN {
    my @cats = qw'
     Commandline_Utilities Desktop Libs Web Web_Applications
     _obsolete _PostInstallLast
     ';
    @main::categories{map {lc $_} @cats} = @cats;

    my @archs = qw'x86 x86_64';
    @main::valid_arch{map {lc $_} @archs} = @archs;
}

# vim: set et ts=4 sw=4 :
